#!/bin/sh

trap 'exit_handler' INT QUIT TERM EXIT ABRT SEGV

usage()
{
  echo "Usage: `basename $0` [args] "
  echo "-r <cmd>          Start a process"
  echo "                  (on process exit, do SW reset)"
  echo "-t <cmd>          Start a process"
  echo "                  (on process exit, restart max N times,"
  echo "                  then do SW reset)"
  echo "-f <cmd>          Start a process"
  echo "                  (on process exit, restart max N times,"
  echo "                  then stop trying)"
  echo "-o <cmd>          Start a process only once"
  echo "-c <num>          Restart process only maximum N times"
  echo "-S <signal>       Set (initial) termination signal"
  echo "-O                Mark for OOM protection (if permitted)"
  echo "-U <username>     Set used uid for started process from"
  echo "                  username"
  echo "-d                Do not fork"
  echo "-n <num>          Set used nice value (if permitted)"
  echo "-T <num>          Restart delay (unimplemented)"
  echo "-s                Start-dbus services, unimplemented"
}

exit_handler()
{
  echo "`basename $0`: exiting"
  kill -$SIGNAL $PID > /dev/null 2>&1
  sleep 2
  kill -9 $PID > /dev/null 2>&1

  # FIXME: this _should_ exit instantly within trap handler, but doesn't.
  exit 0
}

if [ $# -eq 0 ];
then
  usage
  exit 0
fi

do_sw_reset()
{
  COUNT=5

  echo "`basename $0`: critical command $BIN failed. Self-destruct in 5 seconds. Have a nice day.."
  while [ $COUNT -gt 0 ] ;
  do
    echo $COUNT
    COUNT=$((COUNT-1))
    sleep 1
  done
  echo "Resetting node."
  dbus-send --system --print-reply --dest=com.nokia.dsme /com/nokia/dsme com.nokia.dsme.request.req_reboot
}

start_task()
{
  # FIXME: implement nice and possibly user.
  $1 &
  PID=$!

  if [ $OOM_PROTECT ] ;
  then
    echo "-17" >> /proc/$PID/oom_adj > /dev/null 2>&1 
  fi

  BIN=`basename $1`
  echo "`basename $0`: program $BIN started, pid $PID"

  wait $PID

  # Note: we don't need to check if X exiting was the reason for 
  # dying as we're signaled from pre-stop. 
}

start_critical()
{
  TASK=$1

  start_task $1
  do_sw_reset
}

start_critical_with_retries()
{
  TASK=$1
  RETRIES=$2
  COUNT=0

  while [ $COUNT -lt $RETRIES ];
  do
    start_task $TASK 
    COUNT=$((COUNT+1))
  done
  do_sw_reset
}

start_noncritical_with_retries()
{
  TASK=$1
  RETRIES=$2
  COUNT=0

  while [ $COUNT -lt $RETRIES ];
  do
    start_task $TASK
    COUNT=$((COUNT+1))
  done
}

SIGNAL=15
RETRIES=3
ARGUMENTS=$@

set -- `getopt "dhsr:t:f:o:n:c:U:T:S:O" "$@"`

# FIXME: implement command argument checking..

while [ ! -z "$1" ]
do
    case "$1" in
	-h)	
		usage
		exit 0
		;;
	-v)	echo "`basename $0` version 0.1"
		exit 0
		;;
	-r)	CRITICAL_TASK=`echo $2 | sed s/=//`
		TASK=$CRITICAL_TASK
		shift 2
		;;
	-t)	CRITICAL_RETRY=`echo $2 | sed s/=//`
		TASK=$CRITICAL_RETRY
		shift 2
		;;
	-f)	NONCRITICAL_RETRY=`echo $2 | sed s/=//`
		TASK=$NONCRITICAL_RETRY
		shift 2
		;;
	-o)	NONCRITICAL=`echo $2 | sed s/=//`
		TASK=$NONCRITICAL
		shift 2
		;;
	-c)	RETRIES=`echo $2 | sed s/=//`
		shift 2
		;;
	-n)	NICELEVEL=`echo $2 | sed s/=//`
		shift 2
		;;
	-U)	USER=`echo $2 | sed s/=//`
		shift 2
		;;
	-S)	SIGNAL=`echo $2 | sed s/=//`
		shift 2
		;;
	-T)	RESTARTT=`echo $2 | sed s/=//`
		shift 2
		;;
	-O)	OOM_PROTECT=1
		shift
		;;
        -d)     FORKED=1
                shift
                ;;
	-s|--start-dbus)
		shift
		break
		;;
	*)	shift
		break 
		;;
    esac
done

if [ $FORKED ] ;
then
  echo "`basename $0`: task $TASK starting"
else
  $0 -d $ARGUMENTS &
  exit 0
fi

if [ "$CRITICAL_TASK" ] ;
then
  start_critical "$CRITICAL_TASK"
elif [ "$CRITICAL_RETRY" ] ;
then
  start_critical_with_retries "$CRITICAL_RETRY" $RETRIES
elif [ "$NONCRITICAL_RETRY" ] ;
then
  start_noncritical_with_retries "$NONCRITICAL_RETRY" $RETRIES
elif [ "$NONCRITICAL" ] ;
then
  start_task "$NONCRITICAL"
fi

exit 0
